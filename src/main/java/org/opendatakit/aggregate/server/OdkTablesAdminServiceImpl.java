/*
 * Copyright (C) 2012-2013 University of Washington
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package org.opendatakit.aggregate.server;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.opendatakit.aggregate.ContextFactory;
import org.opendatakit.aggregate.client.exception.RequestFailureException;
import org.opendatakit.aggregate.client.preferences.OdkTablesAdmin;
import org.opendatakit.aggregate.client.preferences.OdkTablesAdminService;
import org.opendatakit.aggregate.odktables.OdkTablesUserInfoTable;
import org.opendatakit.common.persistence.CommonFieldsBase;
import org.opendatakit.common.persistence.Datastore;
import org.opendatakit.common.persistence.Query;
import org.opendatakit.common.persistence.client.exception.DatastoreFailureException;
import org.opendatakit.common.persistence.exception.ODKDatastoreException;
import org.opendatakit.common.security.SecurityUtils;
import org.opendatakit.common.security.client.UserSecurityInfo;
import org.opendatakit.common.security.client.exception.AccessDeniedException;
import org.opendatakit.common.security.spring.RegisteredUsersTable;
import org.opendatakit.common.web.CallingContext;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;

public class OdkTablesAdminServiceImpl extends RemoteServiceServlet implements
    OdkTablesAdminService {

  /**
   * Serialization Identifier
   */
  private static final long serialVersionUID = -2602832816355702415L;

  /**
   * This method should return the list of all the admins/users in the
   * datastore. Currently from the table generated by DataStoreUserData. NB:
   * Does not use the simple datastore interaction--might need to be careful if
   * that is what the other OdkTables things use.
   */
  @Override
  public OdkTablesAdmin[] listAdmin() throws AccessDeniedException, DatastoreFailureException {
    try {
      CallingContext cc = this.getCC();
      // get the datastore from which you will get the user info
      Datastore ds = cc.getDatastore();
      OdkTablesUserInfoTable prototype = OdkTablesUserInfoTable.assertRelation(cc);
      // query for the users
      Query query = ds.createQuery(prototype, "OdkTablesAdminServiceImpl.listAdmin",
          cc.getCurrentUser());
      List<? extends CommonFieldsBase> results = query.executeQuery();

      // at this point results should be a list of DataStoreUserData objects
      if (!results.isEmpty()) {
        // make a new array of OdkAdmins to returns
        OdkTablesAdmin[] listOfAdmins = new OdkTablesAdmin[results.size()];
        for (int i = 0; i < results.size(); i++) {
          // make a temporary Admin object to fill with data.
          // cast like crazy to get the info, fill it, and then set it to
          // the array.
          OdkTablesAdmin holder = new OdkTablesAdmin();
          OdkTablesUserInfoTable result = (OdkTablesUserInfoTable) results.get(i);
          holder.setUriUser(result.getUriUser());
          holder.setOdkTablesUserId(result.getOdkTablesUserId());
          holder.setPhoneNumber(result.getPhoneNumber());
          holder.setXBearerCode(result.getXBearerCode());

          RegisteredUsersTable t = RegisteredUsersTable.getUserByUri(result.getUriUser(), ds,
              cc.getCurrentUser());
          UserSecurityInfo info = new UserSecurityInfo(t.getUsername(), t.getFullName(),
              t.getEmail(), UserSecurityInfo.UserType.REGISTERED);
          holder.setName(info.getCanonicalName());
          listOfAdmins[i] = holder;
        }
        return listOfAdmins;
      }

    } catch (ODKDatastoreException e) {
      e.printStackTrace();
      throw new DatastoreFailureException(e);
    }

    return new OdkTablesAdmin[0];
  }

  /**
   * Deletes an ODK Tables admin from the datastore.
   *
   * @throws DatastoreFailureException
   */
  @Override
  public Boolean deleteAdmin(String uriUser) throws AccessDeniedException,
      DatastoreFailureException {
    CallingContext cc = this.getCC();
    try {
      // First turn the string ID into an EntityKey so it can be deleted
      OdkTablesUserInfoTable userToDelete = OdkTablesUserInfoTable.getUserData(uriUser, cc);
      cc.getDatastore().deleteEntity(userToDelete.getEntityKey(), cc.getCurrentUser());
    } catch (ODKDatastoreException e) {
      // If you've gotten here there was a datastore problem
      e.printStackTrace();
      throw new DatastoreFailureException(e);
    }
    return true;
  }

  @Override
  public Boolean updateAdmin(OdkTablesAdmin admin) throws AccessDeniedException {
    return true;
  }

  private CallingContext getCC() {
    // should this not be this? should it really be super?
    HttpServletRequest req = super.getThreadLocalRequest();
    return ContextFactory.getCallingContext(this, req);
  }

  @Override
  public Boolean setAdmins(ArrayList<UserSecurityInfo> admins) throws AccessDeniedException,
      RequestFailureException, DatastoreFailureException {
    CallingContext cc = this.getCC();
    boolean failure = false;
    try {
      OdkTablesUserInfoTable prototype = OdkTablesUserInfoTable.assertRelation(cc);
      for (UserSecurityInfo info : admins) {
        try {
          RegisteredUsersTable theUser = null;
          String odkTablesUserId = null;
          if (info.getEmail() != null) {
            odkTablesUserId = info.getEmail();
            theUser = RegisteredUsersTable.getUserByEmail(info.getEmail(), cc.getUserService(),
                cc.getDatastore());
          } else if (info.getUsername() != null) {
            odkTablesUserId = SecurityUtils.USERNAME_COLON + info.getUsername();
            theUser = RegisteredUsersTable.getUserByUsername(info.getUsername(),
                cc.getUserService(), cc.getDatastore());
          }
          if (theUser == null) {
            failure = true;
            continue;
          }
          OdkTablesUserInfoTable odkTablesUserInfo = OdkTablesUserInfoTable.getUserData(
              theUser.getUri(), cc);
          if (odkTablesUserInfo == null) {
            odkTablesUserInfo = cc.getDatastore().createEntityUsingRelation(prototype,
                cc.getCurrentUser());
            odkTablesUserInfo.setUriUser(theUser.getUri());
          }
          odkTablesUserInfo.setOdkTablesUserId(odkTablesUserId);
          odkTablesUserInfo.persist(cc);
        } catch (ODKDatastoreException e) {
          // If you've gotten here there was a datastore problem
          e.printStackTrace();
          failure = true;
        }
      }
    } catch (ODKDatastoreException e) {
      // If you've gotten here there was a datastore problem
      e.printStackTrace();
      failure = true;
    }
    return !failure;
  }

}
