package org.opendatakit.aggregate.odktables.client.api;

import java.io.IOException;
import java.net.URI;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.NotImplementedException;
import org.opendatakit.aggregate.odktables.client.entity.Column;
import org.opendatakit.aggregate.odktables.client.entity.Row;
import org.opendatakit.aggregate.odktables.client.entity.TableEntry;
import org.opendatakit.aggregate.odktables.client.exception.TableAlreadyExistsException;
import org.opendatakit.aggregate.odktables.client.exception.TableDoesNotExistException;
import org.opendatakit.aggregate.odktables.client.exception.UserDoesNotExistException;

/**
 * SimpleAPI contains API calls for using Aggregate as a simple table storage service.
 */
public class SimpleAPI extends CommonAPI
    {

    /**
     * Constructs a new instance of SimpleAPI, using the supplied user identification for API calls which require it.
     *
     * @param aggregateURI the URI of a running ODK Aggregate instance
     * @param userID the ID of the user to use for API calls
     * @throws IOException if there is a problem communicating with the Aggregate server or if it does not exist
     * @throws UserDoesNotExistException if no user with userID exists in Aggregate
     * @throws AggregateInternalErrorException if Aggregate encounters an
     * internal error that causes the initial communication to fail
     */
    public SimpleAPI(URI aggregateURI, String userID)
    {
        super(aggregateURI);
        throw new NotImplementedException();
    }

    /**
     * Creates a new simple table. The userID used to make the API call will become the owner of the table, and automatically be granted all permissions.
     *
     * @param tableID the identifier which you will use to track the table on the client side
     * @param tableName the human readable name of the table
     * @param columns a list of columns defining the columns the table should have
     * @return the tableUUID of the table, which is universally unique. Aggregate will require you to use this identifier to identify the table.
     * @throws TableAlreadyExistsException if you have already created a table with tableID
     * @throws AggregateInternalErrorException if Aggregate encounters an
     * internal error that causes the call to fail
     * @throws IOException if there is a problem communicating with the Aggregate server
     */
    public String createTable(String tableID, String tableName, List<Column> columns)
    {
        throw new NotImplementedException();
    }

    /**
     * Deletes a table.
     *
     * @param tableUUID the universally unique identifier of the table
     * @throws TableDoesNotExistException if the table does not exist
     * @throws PermissionDeniedException if the userID used to make the API call does not have delete permission on the table
     * @throws AggregateInternalErrorException if Aggregate encounters an
     * internal error that causes the call to fail
     * @throws IOException if there is a problem communicating with the Aggregate server
     */
    public void deleteTable(String tableUUID)
    {
        throw new NotImplementedException();
    }

    /**
     * @return a list of information on all tables the user who made the API call has permisison to read
     * @throws AggregateInternalErrorException if Aggregate encounters an
     * internal error that causes the call to fail
     * @throws IOException if there is a problem communicating with the Aggregate server
     */
    public List<TableEntry> listAllTables()
    {
        throw new NotImplementedException();
    }

    /**
     * @return a list of all rows in the table with tableUUID
     * @throws TableDoesNotExistException if no table with tableUUID exists
     * @throws PermissonDeniedException if the userID used to make the API call does not have read permission on the table
     * @throws AggregateInternalErrorException if Aggregate encounters an
     * internal error that causes the call to fail
     * @throws IOException if there is a problem communicating with the Aggregate server
     */
    public List<Row> getAllRows(String tableUUID)
    {
        throw new NotImplementedException();
    }

    /**
     * Inserts the given rows into the given table.
     *
     * @param tableUUID the universally unique identifier of a table
     * @param rows the rows to insert into the table. The rowIDs of these rows should not have previously been inserted into the table.
     * @return a map of the rowIDs inserted to the rowUUIDs generated by Aggregate. You must store these rowUUIDs in order to identify the rows to Aggregate in the future.
     * @throws TableDoesNotExistException if no table with tableUUID exists
     * @throws PermissionDeniedException if the userID used to make the API call does not have write permission on the table
     * @throws AggregateInternalErrorException if Aggregate encounters an
     * internal error that causes the call to fail
     * @throws IOException if there is a problem communicating with the Aggregate server
     */
    public Map<String, String> insertRows(String tableUUID, List<Row> rows)
    {
        throw new NotImplementedException();
    }
    }
